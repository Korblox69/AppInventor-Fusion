async function mergeProjects() {
    try {
        // Reiniciar estado
        screenRenames.clear();
        resetProgressBar();
        logToConsole("🚀 Iniciant procés de fusió avançat...", 'info');

        // Verificar proyectos cargados
        if (!mainProject.zip || !secondProject.zip) {
            throw new Error("Cal carregar ambdós projectes abans de fusionar");
        }

        // Crear ZIP fusionat
        const mergedZip = new JSZip();
        logToConsole("🔧 Creant estructura bàsica del projecte...", 'info');
        mergedZip.file("youngandroidproject/project.properties", `#Project properties\nname=ProjecteFusionat\n`);

        // Recopilar elementos seleccionados
        const selected = {
            main: {
                screens: getSelectedElements('main', 'screen'),
                assets: getSelectedElements('main', 'asset')
            },
            second: {
                screens: getSelectedElements('second', 'screen'),
                assets: getSelectedElements('second', 'asset')
            }
        };

        // Detección avanzada de conflictos
        logToConsole("🔍 Analitzant conflictes potencials...", 'info');
        const conflictReport = analyzeConflicts(selected.main.screens, selected.second.screens);
        if (conflictReport.total > 0) {
            logToConsole(`⚠️ S'han detectat ${conflictReport.total} conflictes:`, 'warning');
            conflictReport.conflicts.forEach(c => 
                logToConsole(`• ${c.type}: ${c.name} → ${c.newName}`, 'warning'));
        }

        // Procesamiento optimizado con Promise.all()
        logToConsole("⚙️ Processant continguts dels projectes...", 'info');
        await processProjectContent('main', selected.main, mergedZip, conflictReport);
        await processProjectContent('second', selected.second, mergedZip, conflictReport);

        // Generar archivo final
        logToConsole("📦 Generant fitxer .aia fusionat...", 'info');
        const content = await mergedZip.generateAsync({ type: "blob" });
        
        // Descarga automática
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = `projecte_fusionat_${new Date().toISOString().slice(0,10)}.aia`;
        link.click();
        
        logToConsole("✅ Fusió completada amb èxit!", 'success');
        simulateProgress(100, 100, 500);

    } catch (error) {
        logToConsole(`❌ Error crític: ${error.message}`, 'error');
        resetProgressBar();
    }
}

// Función auxiliar moderna para procesar contenido
async function processProjectContent(projectType, selected, mergedZip, conflictReport) {
    const project = projectType === 'main' ? mainProject : secondProject;
    const processor = new ProjectProcessor(project.zip, mergedZip, conflictReport);
    
    await Promise.all([
        processor.processScreens(selected.screens),
        processor.processAssets(selected.assets)
    ]);
}

class ProjectProcessor {
    constructor(sourceZip, targetZip, conflictReport) {
        this.sourceZip = sourceZip;
        this.targetZip = targetZip;
        this.conflictReport = conflictReport;
    }

    async processScreens(screens) {
        return Promise.all(screens.map(async screen => {
            const processed = await this.processScreen(screen);
            this.addScreenToZip(processed);
        }));
    }

    async processScreen(screen) {
        const originalName = screen.name;
        const newName = this.conflictReport.renames[originalName] || originalName;
        
        const [scmContent, bkyContent] = await Promise.all([
            this.getFileContent(screen.scmPath),
            this.getFileContent(screen.bkyPath)
        ]);

        return {
            originalName,
            newName,
            scmContent: this.adaptScreenContent(scmContent, newName),
            bkyContent: this.adaptScreenContent(bkyContent, newName),
            paths: this.getNewPaths(screen, newName)
        };
    }

    adaptScreenContent(content, newName) {
        return content
            .replace(/"\$Name"\s*:\s*"([^"]*)"/g, `"$Name":"${newName}"`)
            .replace(/"Title"\s*:\s*"([^"]*)"/g, `"Title":"${newName}"`);
    }

    getNewPaths(screen, newName) {
        return {
            scm: screen.scmPath.replace(screen.name, newName),
            bky: screen.bkyPath.replace(screen.name, newName)
        };
    }

    addScreenToZip(processed) {
        this.targetZip.file(processed.paths.scm, processed.scmContent);
        this.targetZip.file(processed.paths.bky, processed.bkyContent);
    }

    async processAssets(assets) {
        return Promise.all(assets.map(async asset => {
            const content = await this.getFileContent(asset.path);
            this.targetZip.file(asset.path, content);
        }));
    }

    async getFileContent(path) {
        const file = this.sourceZip.file(path);
        if (!file) throw new Error(`Fitxer no trobat: ${path}`);
        return file.async('string');
    }
}

// Análisis moderno de conflictos
function analyzeConflicts(mainScreens, secondScreens) {
    const report = {
        total: 0,
        conflicts: [],
        renames: {}
    };
    
    const allNames = new Set(mainScreens.map(s => s.name));
    
    secondScreens.forEach(screen => {
        if (allNames.has(screen.name)) {
            const newName = generateUniqueName(screen.name, allNames);
            report.total++;
            report.conflicts.push({
                type: 'Pantalla',
                name: screen.name,
                newName: newName
            });
            report.renames[screen.name] = newName;
            allNames.add(newName);
        }
    });
    
    return report;
}

function generateUniqueName(baseName, existingNames, counter = 1) {
    const newName = `${baseName}_${counter}`;
    return existingNames.has(newName) 
        ? generateUniqueName(baseName, existingNames, counter + 1)
        : newName;
}

function getSelectedElements(projectType, elementType) {
    return [...document.querySelectorAll(`.${elementType}-check[data-project="${projectType}"]:checked`)]
        .map(checkbox => {
            const name = checkbox.dataset.name;
            const path = checkbox.dataset.path;
            return { name, path };
        });
}
